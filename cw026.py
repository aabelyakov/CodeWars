# Я, и мой друг Джон, являемся членами клуба «Fat to Fit Club (FFC)».
# Джон беспокоится, потому что каждый месяц публикуется список с весами
# участников, и каждый месяц он последний в списке, что означает, что он
# самый тяжелый.
#
# Я составляю этот список, поэтому сказал ему: «Не волнуйся больше, я изменю
# порядок списка». Было решено приписать числам «вес». Отныне вес числа
# будет равен сумме его цифр.
#
# Например, 99 будет иметь «вес» 18, 100 будет иметь «вес» 1, поэтому в
# списке 100 будет стоять перед 99.
# Учитывая строку с весами членов FFC в нормальном порядке, можете ли вы
# отсортировать эту строку по «весам» этих чисел?
# Пример:
# "56 65 74 100 99 68 86 180 90",
# упорядоченные по номерам весов, становятся:
# "100 180 90 56 65 74 68 86 99"
# Когда два числа имеют одинаковый «вес», давайте классифицируем их так,
# как если бы они были строками (в алфавитном порядке), а не числами:
# "180" предшествует "90", так как, имея тот же «вес» (9), оно предшествует
# строке "90".
# Все числа в списке положительные и список может быть пустым.
# Заметки
# может случиться так, что входная строка содержит начальные и конечные
# пробелы, а также более чем один уникальный пробел между двумя
# последовательными числами.


# from collections import namedtuple


def rec(n):
    if n == 0:
        return 0
    # endif
    return n % 10 + rec(n // 10)
# enddef


def gen(s):
    """Генератор, выдающий следующее целое число из списка l"""
    if s == "":
        return ""
    # endif
    l = [int(x.strip()) for x in s.split(" ") if x != ""]
    # print(l)
    for m in l:
        yield m
    # endfor
# enddef

def order_weight(s):
    # print(s)
    sRes = ""
    lRes1 = [i for i in gen(s)]
    lRes = [rec(i) for i in gen(s)]
    # print(lRes1)
    # print(lRes)
    dRes = dict(zip(lRes1, lRes))
    dResSort = dict(sorted(dRes.items()))
    # print(dResSort)
    for k, z in dResSort.items():
        sRes += str(k) + " "
    # endfor
    return sRes.rstrip()
# enddef


# Потрясающие решения
# def order_weight(s):
#     return ' '.join(sorted(sorted(s.split(' ')), key=lambda x: sum(int(c) for c in x)))
# # enddef


# def order_weight(s):
#     return ' '.join(sorted(s.split(), key=lambda x: (sum(map(int, x)), x)))
# # enddef


if __name__ == "__main__":
    assert order_weight("103 123 4444 99 2000") == "2000 103 123 4444 99"
    assert order_weight(
        "56 65 74 100 99 68 86 180 90"
    ) == "100 180 90 56 65 74 68 86 99"
    assert order_weight(
        "2000 10003 1234000 44444444 9999 11 11 22 123"
    ) == "11 11 2000 10003 22 123 1234000 44444444 9999"
    assert order_weight("") == ""
# endif